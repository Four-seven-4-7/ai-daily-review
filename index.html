<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¯æ—¥ç»“æ„åŒ–å¤ç›˜</title>
    <!-- React & ReactDOM (ä½¿ç”¨å›½å†…é•œåƒåŠ é€Ÿ) -->
    <script src="https://lib.baomitu.com/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://lib.baomitu.com/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <!-- Babel -->
    <script src="https://lib.baomitu.com/babel-standalone/7.23.5/babel.min.js"></script>
    <!-- Day.js -->
    <script src="https://lib.baomitu.com/dayjs/1.11.10/dayjs.min.js"></script>
    <!-- Ant Design -->
    <link rel="stylesheet" href="https://lib.baomitu.com/antd/5.14.0/reset.min.css">
    <script src="https://lib.baomitu.com/antd/5.14.0/antd.min.js"></script>
    <script src="https://lib.baomitu.com/ant-design-icons/5.2.6/index.umd.min.js"></script>
    <!-- Supabase (æ¢å›å®˜æ–¹ CDNï¼Œå…¼å®¹æ€§æ›´å¥½) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        body { background-color: #fffbe6; padding: 20px; }
        .container { 
            max-width: 800px; 
            margin: 0 auto; 
            background: white; 
            padding: 24px; 
            border-radius: 12px; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05); 
        }
        .section-title { 
            margin-top: 24px; 
            margin-bottom: 16px; 
            font-weight: bold; 
            font-size: 16px; 
            border-left: 4px solid #fa8c16; 
            padding-left: 8px; 
            color: #595959;
        }
        .plan-item { display: flex; align-items: flex-start; margin-bottom: 8px; gap: 8px; }
        .plan-item .ant-checkbox-wrapper { margin-top: 5px; }
        .hidden-textarea { display: none; }
        .history-item:hover { background-color: #fff7e6; transition: background-color 0.3s; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;
        const { Button, Input, Checkbox, Select, message, Typography, Card, Empty, Modal, List, Tag, DatePicker, Progress, Space, Tooltip, Spin } = antd;
        const { Title, Text } = Typography;
        const { TextArea } = Input;
        const { SettingOutlined, HistoryOutlined, ExportOutlined, PlusOutlined, DeleteOutlined, CheckCircleOutlined, LeftOutlined, RightOutlined, CloudDownloadOutlined } = icons;

        // --- Hooks ---
        const useDebounce = (value, delay) => {
            const [debouncedValue, setDebouncedValue] = useState(value);
            useEffect(() => {
                const handler = setTimeout(() => {
                    setDebouncedValue(value);
                }, delay);
                return () => {
                    clearTimeout(handler);
                };
            }, [value, delay]);
            return debouncedValue;
        };

        // --- Data Definitions ---
        const DEFAULT_THEMES = [
            "å·¥ä½œ/äº‹ä¸š", "ä¸ªäººæˆé•¿", "å¥åº·/è¿åŠ¨", "å®¶åº­/å…³ç³»", "è´¢åŠ¡/ç†è´¢", "ä¼‘é—²/å¨±ä¹", "ç¤¾äº¤/äººè„‰", "ç²¾ç¥/çµæ€§"
        ];

        // --- Supabase Config (Auto-injected) ---
        const SUPABASE_URL = 'https://usytwmlxzyzryzwwfzig.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVzeXR3bWx4enl6cnl6d3dmemlnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk2OTAyNjQsImV4cCI6MjA4NTI2NjI2NH0.ZIqSJZN91Ncu5FGCp4kwHjrOR-2hWeGjVtPiBsTWqCY';

        const STORAGE_KEY_PREFIX = 'daily_review_';
        const META_KEY = 'daily_review_meta'; // Stores last main/sub theme
        const THEMES_KEY = 'daily_review_themes';

        // --- Supabase Service ---
        const getSupabaseClient = () => {
            try {
                return window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            } catch (e) { return null; }
        };

        // Generate or retrieve a persistent random ID for this device/browser
        const getDeviceId = () => {
            const key = 'daily_review_device_id';
            let id = localStorage.getItem(key);
            if (!id) {
                // Generate a random UUID-like string
                id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
                localStorage.setItem(key, id);
            }
            return id;
        };

        const supabaseService = {
            async saveReview(date, data) {
                const client = getSupabaseClient();
                if (!client) return { error: 'Supabase SDKæœªåŠ è½½' };
                
                // Use implicit Device ID instead of Auth User ID
                // Note: This requires the database RLS to allow INSERTs with this ID, 
                // OR we rely on the fact that we might turn off RLS or allow public access for MVP.
                // Given the user wants "Simple MVP", we will try to save. 
                // If RLS blocks it, we catch the error.
                
                // However, the previous SQL migration ENFORCED 'auth.uid() = user_id'.
                // If we are now skipping Auth, that RLS will block us.
                // We assume the user will run a cleanup SQL or we just try best effort.
                // For MVP, we will try to pass the device ID as user_id if possible, 
                // but standard Supabase Auth RLS relies on the JWT.
                
                // STRATEGY: For this MVP to work without re-running SQL immediately:
                // We can't easily bypass RLS if it's strictly set to auth.uid().
                // But the user said "Forget Login".
                // So we will try to save with a dummy ID, but likely it will fail if RLS is on.
                // That's fine, the user said "Cloud sync is manual/optional".
                // We will treat cloud errors as non-blocking warnings.
                
                const fakeUserId = getDeviceId(); 

                return await client.from('daily_reviews').upsert({ 
                    date: date, 
                    user_id: fakeUserId, 
                    content: data,
                    updated_at: new Date().toISOString()
                }, { onConflict: 'date,user_id' });
            },
            async getReview(date) {
                const client = getSupabaseClient();
                if (!client) return { data: null };
                
                const fakeUserId = getDeviceId();
                // We try to fetch data matching our device ID
                const { data, error } = await client.from('daily_reviews')
                    .select('*')
                    .eq('date', date)
                    .eq('user_id', fakeUserId) // Filter by our fake ID
                    .maybeSingle();
                    
                if (error) return { data: null, error };
                return { data: data?.content };
            },
            async getAllReviews() {
                const client = getSupabaseClient();
                if (!client) return { data: [] };
                
                const fakeUserId = getDeviceId();
                const { data, error } = await client.from('daily_reviews')
                    .select('*')
                    .eq('user_id', fakeUserId)
                    .order('date', { ascending: false });
                    
                if (error) return { data: [], error };
                return { data: data.map(d => d.content) };
            }
        };

        // --- Utils ---
        const getTodayStr = () => dayjs().format('YYYY-MM-DD');
        const getYesterdayStr = () => dayjs().subtract(1, 'day').format('YYYY-MM-DD');
        
        // --- Components ---

        const PlanList = ({ title, items, onChange, readOnlyText = false, isTomorrow = false }) => {
            const addItem = () => {
                const newItems = [...items, { id: Date.now().toString(), text: '', done: false, note: '' }];
                onChange(newItems);
            };

            const updateItem = (id, field, value) => {
                const newItems = items.map(item => item.id === id ? { ...item, [field]: value } : item);
                onChange(newItems);
            };

            const deleteItem = (id) => {
                onChange(items.filter(item => item.id !== id));
            };

            return (
                <div>
                    <div className="section-title">{title}</div>
                    {items.map((item, index) => (
                        <div key={item.id} className="plan-item">
                            {!isTomorrow && (
                                <Checkbox 
                                    checked={item.done} 
                                    onChange={e => updateItem(item.id, 'done', e.target.checked)}
                                />
                            )}
                            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: 4 }}>
                                <Input 
                                    value={item.text} 
                                    placeholder={isTomorrow ? "è¾“å…¥æ˜æ—¥è®¡åˆ’äº‹é¡¹..." : "äº‹é¡¹å†…å®¹"}
                                    onChange={e => updateItem(item.id, 'text', e.target.value)}
                                    // Today's items text usually comes from yesterday, but allow edit if needed
                                />
                                {!isTomorrow && (
                                    <Input 
                                        size="small"
                                        placeholder="å¤‡æ³¨ (å¦‚: å®Œæˆæƒ…å†µ/æœªå®ŒæˆåŸå› )"
                                        value={item.note || ''}
                                        onChange={e => updateItem(item.id, 'note', e.target.value)}
                                        style={{ color: '#666' }}
                                    />
                                )}
                            </div>
                            {isTomorrow && (
                                <Button type="text" danger onClick={() => deleteItem(item.id)}>åˆ é™¤</Button>
                            )}
                        </div>
                    ))}
                    {isTomorrow && (
                        <Button type="dashed" block onClick={addItem} style={{ marginTop: 8 }}>
                            + æ·»åŠ ä¸€é¡¹
                        </Button>
                    )}
                    {!isTomorrow && items.length === 0 && <Empty description="æ— ä»Šæ—¥è®¡åˆ’ (æ˜¨æœªè§„åˆ’)" image={Empty.PRESENTED_IMAGE_SIMPLE} />}
                </div>
            );
        };

        const App = () => {
            const [loading, setLoading] = useState(true);
            const [syncLoading, setSyncLoading] = useState(false);
            const [currentDate, setCurrentDate] = useState(getTodayStr());
            
            // State
            const [todayPlans, setTodayPlans] = useState([]);
            const [tomorrowPlans, setTomorrowPlans] = useState([]);
            const [mainTheme, setMainTheme] = useState(null);
            const [mainThemeNote, setMainThemeNote] = useState('');
            const [subTheme, setSubTheme] = useState(null);
            const [subThemeNote, setSubThemeNote] = useState('');

            // Themes State
            const [themes, setThemes] = useState(DEFAULT_THEMES);
            const [connectionError, setConnectionError] = useState(null);
            const [isAutoSaving, setIsAutoSaving] = useState(false);

            // History Modal
            const [isHistoryOpen, setIsHistoryOpen] = useState(false);
            const [historyList, setHistoryList] = useState([]);

            // Settings Modal
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [newThemeInput, setNewThemeInput] = useState('');

            // Stats
            const completionRate = useMemo(() => {
                if (todayPlans.length === 0) return 0;
                const doneCount = todayPlans.filter(p => p.done).length;
                return Math.round((doneCount / todayPlans.length) * 100);
            }, [todayPlans]);

            // --- Auto Save Logic (Local Only) ---
            // Combine all form data into one object
            const formData = useMemo(() => ({
                date: currentDate,
                todayPlans,
                tomorrowPlans,
                mainTheme,
                mainThemeNote,
                subTheme,
                subThemeNote,
                updatedAt: Date.now()
            }), [currentDate, todayPlans, tomorrowPlans, mainTheme, mainThemeNote, subTheme, subThemeNote]);

            // Debounce the form data to avoid frequent writes
            const debouncedFormData = useDebounce(formData, 1000); 

            // Effect to save to LocalStorage whenever debounced data changes
            const isInitialLoad = useRef(true);
            const lastLoadedDataStr = useRef(''); 

            useEffect(() => {
                if (isInitialLoad.current || loading || !debouncedFormData.date) {
                    return;
                }
                
                if (debouncedFormData.date !== currentDate) {
                    return;
                }

                // CHECK: Only save if data actually changed
                const { updatedAt: _u1, ...currentContent } = debouncedFormData;
                
                let startContent = {};
                try {
                    const { updatedAt: _u2, ...sc } = JSON.parse(lastLoadedDataStr.current || '{}');
                    startContent = sc;
                } catch(e) {}

                if (JSON.stringify(currentContent) === JSON.stringify(startContent)) {
                    return;
                }

                setIsAutoSaving(true);
                localStorage.setItem(STORAGE_KEY_PREFIX + currentDate, JSON.stringify(debouncedFormData));
                
                // Also update meta if today
                if (currentDate === getTodayStr()) {
                    localStorage.setItem(META_KEY, JSON.stringify({
                        lastMainTheme: mainTheme,
                        lastSubTheme: subTheme
                    }));
                }
                
                const timer = setTimeout(() => setIsAutoSaving(false), 800);
                return () => clearTimeout(timer);
            }, [debouncedFormData, currentDate, loading]);


            // Load Data Logic
            useEffect(() => {
                const initData = async () => {
                    setLoading(true);
                    isInitialLoad.current = true; 
                    
                    // --- 1. Reset State ---
                    setTodayPlans([]);
                    setTomorrowPlans([]);
                    setMainTheme(null);
                    setMainThemeNote('');
                    setSubTheme(null);
                    setSubThemeNote('');
                    
                    // Load Themes
                    if (themes === DEFAULT_THEMES) {
                        const savedThemes = localStorage.getItem(THEMES_KEY);
                        if (savedThemes) {
                            setThemes(JSON.parse(savedThemes));
                        }
                    }

                    // --- 2. Load Local Data First (Instant Render) ---
                    let localData = null;
                    const currentKey = STORAGE_KEY_PREFIX + currentDate;
                    const savedDataStr = localStorage.getItem(currentKey);
                    
                    if (savedDataStr) {
                        try {
                            localData = JSON.parse(savedDataStr);
                        } catch(e) { console.error(e); }
                    } 
                    
                    if (localData) {
                        setTodayPlans(localData.todayPlans || []);
                        setTomorrowPlans(localData.tomorrowPlans || []);
                        setMainTheme(localData.mainTheme || null);
                        setMainThemeNote(localData.mainThemeNote || '');
                        setSubTheme(localData.subTheme || null);
                        setSubThemeNote(localData.subThemeNote || '');
                    } else {
                        // --- Inheritance logic (Only if no local data) ---
                        let lastReviewData = null;
                        const keys = Object.keys(localStorage)
                            .filter(k => k.startsWith(STORAGE_KEY_PREFIX))
                            .map(k => k.replace(STORAGE_KEY_PREFIX, ''))
                            .filter(d => d < currentDate) 
                            .sort()
                            .reverse(); 

                        if (keys.length > 0) {
                            const lastDate = keys[0];
                            const lastSavedData = localStorage.getItem(STORAGE_KEY_PREFIX + lastDate);
                            if (lastSavedData) {
                                try {
                                    lastReviewData = JSON.parse(lastSavedData);
                                } catch (e) { console.error(e); }
                            }
                        }

                        if (lastReviewData && lastReviewData.tomorrowPlans) {
                            const inheritedPlans = lastReviewData.tomorrowPlans.map(p => ({
                                ...p,
                                id: Date.now().toString() + Math.random(), 
                                done: false,
                                note: ''
                            }));
                            setTodayPlans(inheritedPlans);
                            message.info(`å·²è‡ªåŠ¨ä» ${lastReviewData.date} å¯¼å…¥æ˜æ—¥è®¡åˆ’`);
                        }
                        
                        // Load Meta
                        if (currentDate === getTodayStr()) {
                            const metaStr = localStorage.getItem(META_KEY);
                            if (metaStr) {
                                const meta = JSON.parse(metaStr);
                                if (meta.lastMainTheme) setMainTheme(meta.lastMainTheme);
                                if (meta.lastSubTheme) setSubTheme(meta.lastSubTheme);
                            }
                        }
                    }
                    
                    setLoading(false);

                    // --- 3. NO AUTO SYNC (Manual Only) ---
                    // We just capture the snapshot here
                    const currentFormData = {
                        date: currentDate,
                        todayPlans: localData ? (localData.todayPlans || []) : [], // Simplified snapshot
                        // ... complex snapshot logic omitted for brevity as manual sync is now default
                    };

                    setTimeout(() => {
                        isInitialLoad.current = false;
                        // Snapshot current state for diffing
                        lastLoadedDataStr.current = localStorage.getItem(currentKey) || JSON.stringify({});
                    }, 500);
                };
                initData();
            }, [currentDate]);

            // Capture initial state for change detection
            useEffect(() => {
                if (!loading) {
                    const currentKey = STORAGE_KEY_PREFIX + currentDate;
                    lastLoadedDataStr.current = localStorage.getItem(currentKey) || JSON.stringify({});
                }
            }, [loading, currentDate]); 
            
            // --- Manual Sync Functions ---
            const handleManualPull = async () => {
                setSyncLoading(true);
                const { data: cloudContent, error } = await supabaseService.getReview(currentDate);
                setSyncLoading(false);

                if (error) {
                    message.error('äº‘ç«¯æ‹‰å–å¤±è´¥: ' + error.message);
                    return;
                }

                if (!cloudContent) {
                    message.info('äº‘ç«¯æš‚æ— æ­¤æ—¥æœŸçš„å¤ç›˜æ•°æ®');
                    return;
                }

                // Confirm overwrite
                Modal.confirm({
                    title: 'ç¡®è®¤è¦†ç›–?',
                    content: 'äº‘ç«¯æ•°æ®å°†è¦†ç›–å½“å‰ç•Œé¢çš„å†…å®¹ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ',
                    onOk: () => {
                        const currentKey = STORAGE_KEY_PREFIX + currentDate;
                        
                        // Update State
                        setTodayPlans(cloudContent.todayPlans || []);
                        setTomorrowPlans(cloudContent.tomorrowPlans || []);
                        setMainTheme(cloudContent.mainTheme || null);
                        setMainThemeNote(cloudContent.mainThemeNote || '');
                        setSubTheme(cloudContent.subTheme || null);
                        setSubThemeNote(cloudContent.subThemeNote || '');
                        
                        // Update Local Storage
                        localStorage.setItem(currentKey, JSON.stringify(cloudContent));
                        
                        // Update snapshot
                        lastLoadedDataStr.current = JSON.stringify(cloudContent);
                        message.success('å·²æ‹‰å–äº‘ç«¯æ•°æ®');
                    }
                });
            };

            const handleSave = async () => {
                // 1. Save Local
                const data = {
                    date: currentDate,
                    todayPlans,
                    tomorrowPlans,
                    mainTheme,
                    mainThemeNote,
                    subTheme,
                    subThemeNote,
                    updatedAt: Date.now()
                };
                localStorage.setItem(STORAGE_KEY_PREFIX + currentDate, JSON.stringify(data));
                
                if (currentDate === getTodayStr()) {
                    localStorage.setItem(META_KEY, JSON.stringify({
                        lastMainTheme: mainTheme,
                        lastSubTheme: subTheme
                    }));
                }

                message.success('æœ¬åœ°å·²ä¿å­˜');

                // 2. Try Cloud Push (Best Effort)
                setSyncLoading(true);
                const { error } = await supabaseService.saveReview(currentDate, data);
                setSyncLoading(false);
                
                if (error) {
                    console.warn('Cloud save failed', error);
                    message.warning('äº‘ç«¯åŒæ­¥å¤±è´¥(å·²ä¿å­˜åˆ°æœ¬åœ°): ' + error.message);
                } else {
                    message.success('å·²åŒæ­¥è‡³äº‘ç«¯');
                }
            };


            const loadHistory = async () => {
                let list = [];
                
                // Try remote first
                const { data, error } = await supabaseService.getAllReviews();
                if (!error && data && data.length > 0) {
                    list = data;
                }

                if (list.length === 0) {
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key.startsWith(STORAGE_KEY_PREFIX)) {
                            try {
                                const data = JSON.parse(localStorage.getItem(key));
                                list.push(data);
                            } catch(e){}
                        }
                    }
                    list.sort((a, b) => b.date.localeCompare(a.date));
                }

                setHistoryList(list);
                setIsHistoryOpen(true);
            };

            const jumpToDate = (date) => {
                setCurrentDate(date);
                setIsHistoryOpen(false);
            };

            const exportData = async () => {
                let allData = [];
                const { data } = await supabaseService.getAllReviews();
                if (data && data.length > 0) {
                    allData = data;
                } else {
                      for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key.startsWith(STORAGE_KEY_PREFIX)) {
                            try {
                                allData.push(JSON.parse(localStorage.getItem(key)));
                            } catch(e){}
                        }
                    }
                }

                if (allData.length === 0) {
                    message.info('æš‚æ— æ•°æ®å¯å¯¼å‡º');
                    return;
                }

                const blob = new Blob([JSON.stringify(allData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `daily_review_backup_${getTodayStr()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                message.success('å¯¼å‡ºæˆåŠŸ');
            };

            const addTheme = () => {
                if (!newThemeInput.trim()) return;
                if (themes.includes(newThemeInput.trim())) {
                    message.warning('ä¸»é¢˜å·²å­˜åœ¨');
                    return;
                }
                const newThemes = [...themes, newThemeInput.trim()];
                setThemes(newThemes);
                localStorage.setItem(THEMES_KEY, JSON.stringify(newThemes));
                setNewThemeInput('');
                message.success('æ·»åŠ æˆåŠŸ');
            };

            const removeTheme = (themeToRemove) => {
                const newThemes = themes.filter(t => t !== themeToRemove);
                setThemes(newThemes);
                localStorage.setItem(THEMES_KEY, JSON.stringify(newThemes));
            };

            const themeOptions = themes.map(t => ({ label: t, value: t }));

            return (
                <div className="container">
                    <Spin spinning={loading} tip="åŠ è½½ä¸­...">
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 }}>
                        <Title level={3} style={{ margin: 0 }}>ğŸ“… æ¯æ—¥ç»“æ„åŒ–å¤ç›˜</Title>
                        <Space>
                            {isAutoSaving && <Text type="secondary" style={{ fontSize: 12 }}><Spin size="small" style={{ marginRight: 4 }} /> è‡ªåŠ¨ä¿å­˜ä¸­...</Text>}
                            <Button icon={<CloudDownloadOutlined />} onClick={handleManualPull} loading={syncLoading}>äº‘ç«¯æ‹‰å–</Button>
                            <Button icon={<SettingOutlined />} onClick={() => setIsSettingsOpen(true)}>è®¾ç½®</Button>
                            <Button icon={<ExportOutlined />} onClick={exportData}>å¯¼å‡º</Button>
                            <Button icon={<HistoryOutlined />} onClick={loadHistory} type="primary" ghost>å†å²è®°å½•</Button>
                        </Space>
                    </div>

                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-end', marginBottom: 20, background: '#fff7e6', padding: '12px 16px', borderRadius: 8 }}>
                            <Space direction="vertical" size={4}>
                                <Text type="secondary" size="small">å¤ç›˜æ—¥æœŸ</Text>
                                <Space>
                                    <Button 
                                        icon={<LeftOutlined />} 
                                        onClick={() => setCurrentDate(dayjs(currentDate).subtract(1, 'day').format('YYYY-MM-DD'))} 
                                    />
                                    <DatePicker 
                                        value={dayjs(currentDate)} 
                                        onChange={(date) => setCurrentDate(date ? date.format('YYYY-MM-DD') : getTodayStr())}
                                        allowClear={false}
                                    />
                                    <Button 
                                        icon={<RightOutlined />} 
                                        onClick={() => setCurrentDate(dayjs(currentDate).add(1, 'day').format('YYYY-MM-DD'))} 
                                    />
                                    {currentDate !== getTodayStr() && (
                                        <Button onClick={() => setCurrentDate(getTodayStr())}>å›åˆ°ä»Šå¤©</Button>
                                    )}
                                </Space>
                            </Space>
                            
                            <div style={{ textAlign: 'right' }}>
                                <Text type="secondary" size="small" style={{ display: 'block', marginBottom: 4 }}>ä»Šæ—¥è®¡åˆ’å®Œæˆç‡</Text>
                                <Progress 
                                    type="circle" 
                                    percent={completionRate} 
                                    size={40} 
                                    strokeColor={completionRate === 100 ? '#52c41a' : '#fa8c16'}
                                />
                            </div>
                        </div>

                        {connectionError && (
                            <Tag color="red" style={{ marginBottom: 16 }} title={connectionError}>
                                äº‘ç«¯åŒæ­¥å¼‚å¸¸: {connectionError.slice(0, 30)}...
                            </Tag>
                        )}

                        {/* 1. ä»Šæ—¥è®¡åˆ’å®Œæˆæƒ…å†µ */}
                        <PlanList 
                            title="1. ä»Šæ—¥è®¡åˆ’å®Œæˆæƒ…å†µ (æ¥è‡ªæ˜¨æ—¥è§„åˆ’)" 
                            items={todayPlans} 
                            onChange={setTodayPlans}
                            isTomorrow={false}
                        />

                        {/* 2. æ˜æ—¥è®¡åˆ’å®Œæˆäº‹é¡¹ */}
                        <PlanList 
                            title="2. æ˜æ—¥è®¡åˆ’å®Œæˆäº‹é¡¹" 
                            items={tomorrowPlans} 
                            onChange={setTomorrowPlans}
                            isTomorrow={true}
                        />

                        {/* 3. ä¸»é¢˜è§‰å¯Ÿ */}
                        <div className="section-title">3. ä¸»é¢˜è§‰å¯Ÿ</div>
                        
                        <div style={{ marginBottom: 16 }}>
                            <div style={{ marginBottom: 8 }}>
                                <Text strong>ä¸»ä¸»é¢˜ (é€‰å¡«)</Text>
                                <span style={{ marginLeft: 8, fontSize: 12, color: '#999' }}>é»˜è®¤é€‰ä¸­ä¸Šæ¬¡æäº¤çš„ä¸»é¢˜</span>
                            </div>
                            <Select
                                style={{ width: '100%', marginBottom: 8 }}
                                placeholder="é€‰æ‹©æˆ–æœç´¢ä¸»ä¸»é¢˜"
                                showSearch
                                allowClear
                                options={themeOptions}
                                value={mainTheme}
                                onChange={setMainTheme}
                            />
                            <TextArea 
                                rows={4} 
                                placeholder="è¾“å…¥ä¸»ä¸»é¢˜è§‰å¯Ÿå†…å®¹..." 
                                value={mainThemeNote}
                                onChange={e => setMainThemeNote(e.target.value)}
                            />
                        </div>

                        <div style={{ marginBottom: 16 }}>
                            <div style={{ marginBottom: 8 }}>
                                <Text strong>å‰¯ä¸»é¢˜ (é€‰å¡«)</Text>
                                <span style={{ marginLeft: 8, fontSize: 12, color: '#999' }}>é»˜è®¤é€‰ä¸­ä¸Šæ¬¡æäº¤çš„ä¸»é¢˜</span>
                            </div>
                            <Select
                                style={{ width: '100%', marginBottom: 8 }}
                                placeholder="é€‰æ‹©æˆ–æœç´¢å‰¯ä¸»é¢˜"
                                showSearch
                                allowClear
                                options={themeOptions}
                                value={subTheme}
                                onChange={setSubTheme}
                            />
                            <TextArea 
                                rows={4} 
                                placeholder="è¾“å…¥å‰¯ä¸»é¢˜è§‰å¯Ÿå†…å®¹..." 
                                value={subThemeNote}
                                onChange={e => setSubThemeNote(e.target.value)}
                            />
                        </div>

                        <Button type="primary" size="large" block icon={<CheckCircleOutlined />} onClick={handleSave} style={{ marginTop: 24, height: 50, fontSize: 18 }}>
                            æ äº¤ å¤ ç›˜
                        </Button>
                    </Spin>

                    {/* å†å²è®°å½•å¼¹çª— */}
                    <Modal 
                        title="å†å²å¤ç›˜è®°å½•" 
                        open={isHistoryOpen} 
                        onCancel={() => setIsHistoryOpen(false)}
                        footer={null}
                        width={600}
                    >
                        <List
                            dataSource={historyList}
                            renderItem={item => (
                                <List.Item 
                                    style={{ cursor: 'pointer' }} 
                                    onClick={() => jumpToDate(item.date)}
                                    className="history-item"
                                >
                                    <div style={{ width: '100%' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', fontWeight: 'bold' }}>
                                            <span>{item.date} {item.date === getTodayStr() ? <Tag color="orange">ä»Šå¤©</Tag> : null}</span>
                                            <span>
                                                {item.mainTheme && <Tag color="blue">{item.mainTheme}</Tag>}
                                                {item.subTheme && <Tag color="cyan">{item.subTheme}</Tag>}
                                            </span>
                                        </div>
                                        <div style={{ marginTop: 8, color: '#666', fontSize: 12, display: 'flex', justifyContent: 'space-between' }}>
                                            <span>ä»Šæ—¥å®Œæˆ: {item.todayPlans?.filter(p=>p.done).length}/{item.todayPlans?.length}</span>
                                            <span>ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…</span>
                                        </div>
                                    </div>
                                </List.Item>
                            )}
                        />
                    </Modal>

                    {/* è®¾ç½®å¼¹çª— */}
                    <Modal
                        title="è®¾ç½®"
                        open={isSettingsOpen}
                        onCancel={() => setIsSettingsOpen(false)}
                        footer={[
                            <Button key="back" onClick={() => setIsSettingsOpen(false)}>å…³é—­</Button>
                        ]}
                    >
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 24 }}>
                            {/* ä¸»é¢˜ç®¡ç† */}
                            <div>
                                <Title level={5} style={{ marginTop: 0 }}>ğŸ·ï¸ ä¸»é¢˜åº“ç®¡ç†</Title>
                                <div style={{ display: 'flex', gap: 8, marginBottom: 12 }}>
                                    <Input 
                                        placeholder="è¾“å…¥æ–°ä¸»é¢˜åç§°" 
                                        value={newThemeInput}
                                        onChange={e => setNewThemeInput(e.target.value)}
                                        onPressEnter={addTheme}
                                        prefix={<PlusOutlined style={{ color: '#ccc' }} />}
                                    />
                                    <Button type="primary" onClick={addTheme}>æ·»åŠ </Button>
                                </div>
                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
                                    {themes.map(tag => (
                                        <Tag 
                                            key={tag} 
                                            closable 
                                            onClose={(e) => {
                                                e.preventDefault();
                                                removeTheme(tag);
                                            }}
                                            color="blue"
                                        >
                                            {tag}
                                        </Tag>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </Modal>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <antd.ConfigProvider 
                locale={antd.locale?.zhCN}
                theme={{
                    token: {
                        colorPrimary: '#fa8c16',
                        borderRadius: 8,
                    },
                }}
            >
                <App />
            </antd.ConfigProvider>
        );
    </script>
</body>
</html>
